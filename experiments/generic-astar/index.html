---
layout: experiment
title: Generic A* Search
tags: [search, astar,]
version: 0.1
date: 2014-09-11 21:50:43
---

<style type="text/css">
 #board td {
   border: 1px solid gray;
   width: 5px;
   height: 5px;
 }

 td.wall {
   background-color: black;
 }

 td.expanded {
   background-color: yellow;
 }

 td.path {
   background-color: green;
 }
 
</style>

<p>
  The following parameters control the matrix generation and search
  algorithm. The first two parameters affect the "reset". The other three values
  affect the search.
</p>
<p>
  Size: <input id="size" type="text" name="" value="80" size="3"/>
  Wall%: <input id="wChance" type="text" name="" value="0.2" size="3"/>
</p>
</p>
  Max Nodes: <input id="maxNodes" type="text" name="" value="-1" size="3"/>
  H Weight: <input id="hWeight" type="text" name="" value="1" size="3"/>
  G Weight: <input id="gWeight" type="text" name="" value="1" size="3"/>
</p>
<p>
  <button onclick="reset();">Reset</button>
  <button onclick="search();">Start</button>
  Nodes: <span id="txtcount">0</span> Time: <span id="txttime">0</span> ms
</p>

<table id="board">
</table>

<script src="js/ext/heap.js"></script>
<script src="js/astar.js"></script>
<script type="text/javascript">
 var table = document.getElementById('board');
 var size = 80;
 var wallChange = 0.2;
 var matrix = new Array(size);
 var results = null;
 var previousPath = [];

 function setLabels(values) {
   for (var name in values) {
     document.getElementById("txt" + name).innerHTML = values[name];
   }
 }

 function getNumber(name) {
   return parseFloat(document.getElementById(name).value);
 }
 
 function reset() {
   // reset labels
   setLabels({ count: 0, time: 0 });
   size = getNumber("size");
   wallChange = getNumber("wChance");
   results = null;
   previousPath = [];

   // remove rows
   while (table.firstChild) {
     table.removeChild(table.firstChild);
   }

   // generate matrix
   for (var i = 0; i < size; i++) {
     var row = document.createElement("tr");   
     matrix[i] = new Array(size);
     for (var j = 0; j < size; j++) {
       if (i == 0 && j == 0) matrix[i][j] = false;
       else if (i == size - 1 && j == size - 1) matrix[i][j] = false;
       else matrix[i][j] = Math.random() <= wallChange;
       
       var td = document.createElement("td");
       td.appendChild(document.createTextNode(" "));
       td.setAttribute("id", "c" + i + "x" + j);
       
       if (matrix[i][j]) {
         td.setAttribute("class", "wall");
       }
       
       row.appendChild(td);
     }
     
     table.appendChild(row);
   }
 }

 function setCellClass(squares, value, override) {
   for (var i = 0; i < squares.length; i++) {
     var x = squares[i].x;
     var y = squares[i].y;
     var td = document.getElementById("c" + y + "x" + x);
     
     var old = td.getAttribute("class");
     if (!old || override) {
       td.setAttribute("class", value);
     }
   }
 }

 function search() {
   if (!results) {
     var maxNodes = getNumber('maxNodes');
     var hWeight = getNumber('hWeight');
     var gWeight = getNumber('gWeight');

     results = astar({
       initial: { x: 0, y: 0 },
       fidentity: function(square) {
         return square.x * size + square.y;
       },
       fgoal: function(square) {
         return square.x == size - 1 && square.y == size - 1;
       },
       fsuccessors: function(square) {
         var neighbors = new Array();
         
         var x = square.x; 
         var y = square.y;

         if (x > 0 && !matrix[y][x - 1]) {
           neighbors.push({ x: x - 1, y: y });
         }

         if (x < size - 1 && !matrix[y][x + 1]) {
           neighbors.push({ x: x + 1, y: y });
         }

         if (y > 0 && !matrix[y - 1][x]) {
           neighbors.push({ x: x, y: y - 1 });
         }

         if (y < size - 1 && !matrix[y + 1][x]) {
           neighbors.push({ x: x, y: y + 1 });
         }

         setCellClass(neighbors, "expanded");
         return neighbors;
       },
       fdistance: function(a, b) {
         return hWeight * (
           Math.abs(a.x - b.x) 
           + Math.abs(a.y - b.y));
       },
       fheuristic: function(square) {
         return gWeight * (
           Math.abs(size - 1 - square.x) 
           + Math.abs(size - 1 - square.y));
       },
       limits: {
         maxNodes: maxNodes
       }
     });
   }
   else if (results.more) {
     results = results.more();
   }

   setCellClass(previousPath, "expanded", true);
   setCellClass(results.path, "path", true);
   previousPath = results.path;

   setLabels({ count: results.count, time: results.elapsed });

   if (results.goal) {
     results = null;
     return;
   }

   if (results.more) {
     setTimeout(search, 0);
   }
 }

 // start by resetting
 setTimeout(reset, 0);
</script>
